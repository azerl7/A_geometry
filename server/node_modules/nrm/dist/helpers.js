"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readFile = readFile;
exports.writeFile = writeFile;
exports.padding = padding;
exports.printSuccess = printSuccess;
exports.printError = printError;
exports.printMessages = printMessages;
exports.geneDashLine = geneDashLine;
exports.isLowerCaseEqual = isLowerCaseEqual;
exports.getCurrentRegistry = getCurrentRegistry;
exports.getRegistries = getRegistries;
exports.isRegistryNotFound = isRegistryNotFound;
exports.isInternalRegistry = isInternalRegistry;
exports.exit = exit;
exports.isUnicodeSupported = isUnicodeSupported;
const node_fs_1 = __importDefault(require("node:fs"));
const node_process_1 = __importDefault(require("node:process"));
const chalk_1 = __importDefault(require("chalk"));
const ini_1 = __importDefault(require("ini"));
const constants_js_1 = require("./constants.js");
async function readFile(file) {
    return new Promise((resolve) => {
        if (!node_fs_1.default.existsSync(file)) {
            resolve({});
        }
        else {
            try {
                const content = ini_1.default.parse(node_fs_1.default.readFileSync(file, 'utf-8'));
                resolve(content);
            }
            catch (error) {
                exit(error);
            }
        }
    });
}
async function writeFile(path, content) {
    return new Promise((resolve) => {
        try {
            node_fs_1.default.writeFileSync(path, ini_1.default.stringify(content));
            resolve();
        }
        catch (error) {
            exit(error);
        }
    });
}
function padding(message = '', before = 1, after = 1) {
    return (new Array(before).fill(' ').join('') +
        message +
        new Array(after).fill(' ').join(''));
}
function printSuccess(message) {
    console.log(`${chalk_1.default.bgGreenBright(padding('SUCCESS'))} ${message}`);
}
function printError(error) {
    console.error(`${chalk_1.default.bgRed(padding('ERROR'))} ${chalk_1.default.red(error)}`);
}
function printMessages(messages) {
    console.log(messages.join('\n'));
}
function geneDashLine(message, length) {
    const finalMessage = new Array(Math.max(2, length - message.length + 2)).join('-');
    return padding(chalk_1.default.dim(finalMessage));
}
function isLowerCaseEqual(str1, str2) {
    if (str1 && str2) {
        return str1.toLowerCase() === str2.toLowerCase();
    }
    return !str1 && !str2;
}
async function getCurrentRegistry() {
    const npmrc = await readFile(constants_js_1.NPMRC);
    return npmrc[constants_js_1.REGISTRY];
}
async function getRegistries() {
    const customRegistries = await readFile(constants_js_1.NRMRC);
    return Object.assign({}, constants_js_1.REGISTRIES, customRegistries);
}
async function isRegistryNotFound(name, printErr = true) {
    const registries = await getRegistries();
    if (!Object.keys(registries).includes(name)) {
        printErr && printError(`The registry '${name}' is not found.`);
        return true;
    }
    return false;
}
async function isInternalRegistry(name, handle) {
    if (Object.keys(constants_js_1.REGISTRIES).includes(name)) {
        handle && printError(`You cannot ${handle} the nrm internal registry.`);
        return true;
    }
    return false;
}
function exit(error) {
    error && printError(error);
    node_process_1.default.exit(1);
}
function isUnicodeSupported() {
    if (node_process_1.default.platform !== 'win32') {
        return node_process_1.default.env.TERM !== 'linux';
    }
    return (Boolean(node_process_1.default.env.WT_SESSION) ||
        Boolean(node_process_1.default.env.TERMINUS_SUBLIME) ||
        node_process_1.default.env.ConEmuTask === '{cmd::Cmder}' ||
        node_process_1.default.env.TERM_PROGRAM === 'Terminus-Sublime' ||
        node_process_1.default.env.TERM_PROGRAM === 'vscode' ||
        node_process_1.default.env.TERM === 'xterm-256color' ||
        node_process_1.default.env.TERM === 'alacritty' ||
        node_process_1.default.env.TERMINAL_EMULATOR === 'JetBrains-JediTerm');
}
