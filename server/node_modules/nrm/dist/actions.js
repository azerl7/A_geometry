"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.onList = onList;
exports.onCurrent = onCurrent;
exports.onUse = onUse;
exports.onDelete = onDelete;
exports.onAdd = onAdd;
exports.onLogin = onLogin;
exports.onSetRepository = onSetRepository;
exports.onSetScope = onSetScope;
exports.onDeleteScope = onDeleteScope;
exports.onSetAttribute = onSetAttribute;
exports.onRename = onRename;
exports.onHome = onHome;
exports.onTest = onTest;
const checkbox_1 = __importDefault(require("@inquirer/checkbox"));
const select_1 = __importDefault(require("@inquirer/select"));
const chalk_1 = __importDefault(require("chalk"));
const open_1 = __importDefault(require("open"));
const undici_1 = require("undici");
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
async function onList() {
    const currentRegistry = await (0, helpers_1.getCurrentRegistry)();
    const registries = await (0, helpers_1.getRegistries)();
    const keys = Object.keys(registries);
    const length = Math.max(...keys.map((key) => key.length)) + 3;
    const messages = keys.map((key) => {
        const registry = registries[key];
        const prefix = (0, helpers_1.isLowerCaseEqual)(registry[constants_1.REGISTRY], currentRegistry)
            ? chalk_1.default.green.bold('* ')
            : '  ';
        return prefix + key + (0, helpers_1.geneDashLine)(key, length) + registry[constants_1.REGISTRY];
    });
    (0, helpers_1.printMessages)(messages);
}
async function onCurrent({ showUrl }) {
    const currentRegistry = await (0, helpers_1.getCurrentRegistry)();
    const registries = await (0, helpers_1.getRegistries)();
    const matchedRegistry = Object.entries(registries).find(([_name, registry]) => (0, helpers_1.isLowerCaseEqual)(registry[constants_1.REGISTRY], currentRegistry));
    // not find equal registry
    if (!matchedRegistry) {
        (0, helpers_1.printMessages)([
            `Your current registry(${currentRegistry}) is not included in the nrm registries.`,
            `Use the ${chalk_1.default.green('nrm add <registry> <url> [home]')} command to add your registry.`,
        ]);
        return;
    }
    const [name, registry] = matchedRegistry;
    (0, helpers_1.printMessages)([
        `You are using ${chalk_1.default.green(showUrl ? registry[constants_1.REGISTRY] : name)} registry.`,
    ]);
}
async function onUse(name) {
    const registries = await (0, helpers_1.getRegistries)();
    let alias = name;
    // if alias is undefined, select the registry alias from list
    if (alias === undefined) {
        alias = await (0, select_1.default)({
            message: 'Please select the registry you want to use',
            choices: Object.keys(registries),
            pageSize: 10,
        });
    }
    if (await (0, helpers_1.isRegistryNotFound)(alias)) {
        return;
    }
    const registry = registries[alias];
    const npmrc = await (0, helpers_1.readFile)(constants_1.NPMRC);
    await (0, helpers_1.writeFile)(constants_1.NPMRC, Object.assign(npmrc, registry));
    (0, helpers_1.printSuccess)(`The registry has been changed to '${alias}'.`);
}
async function onDelete(name) {
    const customRegistries = await (0, helpers_1.readFile)(constants_1.NRMRC);
    const deleteKeys = [];
    if (name) {
        deleteKeys.push(name);
    }
    const choices = Object.keys(customRegistries);
    if (name === undefined && !choices.length) {
        (0, helpers_1.printMessages)(['No any custom registries can be deleted.']);
        return;
    }
    if (name === undefined) {
        const selectedKeys = await (0, checkbox_1.default)({
            message: 'Please select the registries you want to delete',
            choices,
        });
        deleteKeys.push(...selectedKeys);
    }
    for (const key of deleteKeys) {
        if ((await (0, helpers_1.isRegistryNotFound)(key)) ||
            (await (0, helpers_1.isInternalRegistry)(key, 'delete'))) {
            continue;
        }
        const registry = customRegistries[key];
        delete customRegistries[key];
        await (0, helpers_1.writeFile)(constants_1.NRMRC, customRegistries);
        (0, helpers_1.printSuccess)(`The registry '${key}' has been deleted successfully.`);
        const currentRegistry = await (0, helpers_1.getCurrentRegistry)();
        if (currentRegistry === registry[constants_1.REGISTRY]) {
            await onUse('npm');
        }
    }
}
async function onAdd(name, url, home) {
    const registries = await (0, helpers_1.getRegistries)();
    const registryNames = Object.keys(registries);
    const registryUrls = registryNames.map((name) => registries[name][constants_1.REGISTRY]);
    if (registryNames.includes(name) ||
        registryUrls.some((eachUrl) => (0, helpers_1.isLowerCaseEqual)(eachUrl, url))) {
        return (0, helpers_1.exit)('The registry name or url is already included in the nrm registries. Please make sure that the name and url are unique.');
    }
    const newRegistry = {};
    newRegistry[constants_1.REGISTRY] = /\/$/.test(url) ? url : `${url}/`;
    if (home) {
        newRegistry[constants_1.HOME] = home;
    }
    const customRegistries = await (0, helpers_1.readFile)(constants_1.NRMRC);
    const newCustomRegistries = Object.assign(customRegistries, {
        [name]: newRegistry,
    });
    await (0, helpers_1.writeFile)(constants_1.NRMRC, newCustomRegistries);
    (0, helpers_1.printSuccess)(`Add registry ${name} success, run ${chalk_1.default.green(`nrm use ${name}`)} command to use ${name} registry.`);
}
async function onLogin(name, base64, { alwaysAuth, username, password, email, }) {
    if ((await (0, helpers_1.isRegistryNotFound)(name)) ||
        (await (0, helpers_1.isInternalRegistry)(name, 'set authorization information of'))) {
        return;
    }
    const customRegistries = await (0, helpers_1.readFile)(constants_1.NRMRC);
    const registry = customRegistries[name];
    if (base64) {
        registry[constants_1.AUTH] = base64;
    }
    else if (username && password) {
        registry[constants_1.AUTH] = Buffer.from(`${username}:${password}`).toString('base64');
    }
    else {
        return (0, helpers_1.exit)('Authorization information in base64 format or username & password is required');
    }
    if (alwaysAuth) {
        registry[constants_1.ALWAYS_AUTH] = true;
    }
    if (email) {
        registry[constants_1.EMAIL] = email;
    }
    Object.assign(customRegistries, { [name]: registry });
    await (0, helpers_1.writeFile)(constants_1.NRMRC, customRegistries);
    (0, helpers_1.printSuccess)(`Set the authorization information of the registry '${name}' success.`);
    const currentRegistry = await (0, helpers_1.getCurrentRegistry)();
    if (currentRegistry === registry[constants_1.REGISTRY]) {
        const npmrc = await (0, helpers_1.readFile)(constants_1.NPMRC);
        await (0, helpers_1.writeFile)(constants_1.NPMRC, Object.assign(npmrc, {
            [constants_1.AUTH]: registry[constants_1.AUTH],
            [constants_1.ALWAYS_AUTH]: registry[constants_1.ALWAYS_AUTH],
            [constants_1.EMAIL]: registry[constants_1.EMAIL],
        }));
    }
}
async function onSetRepository(name, repo) {
    if ((await (0, helpers_1.isRegistryNotFound)(name)) ||
        (await (0, helpers_1.isInternalRegistry)(name, 'set repository of'))) {
        return;
    }
    const customRegistries = await (0, helpers_1.readFile)(constants_1.NRMRC);
    const registry = customRegistries[name];
    registry[constants_1.REPOSITORY] = repo;
    await (0, helpers_1.writeFile)(constants_1.NRMRC, customRegistries);
    (0, helpers_1.printSuccess)(`Set the ${constants_1.REPOSITORY} of registry '${name}' successfully.`);
    const currentRegistry = await (0, helpers_1.getCurrentRegistry)();
    if (currentRegistry && registry[constants_1.REGISTRY] === currentRegistry) {
        const npmrc = await (0, helpers_1.readFile)(constants_1.NPMRC);
        Object.assign(npmrc, { [constants_1.REPOSITORY]: repo });
        await (0, helpers_1.writeFile)(constants_1.NPMRC, npmrc);
        (0, helpers_1.printSuccess)('Set repository attribute of npmrc successfully');
    }
}
async function onSetScope(scopeName, url) {
    const scopeRegistryKey = `${scopeName}:${constants_1.REGISTRY}`;
    const npmrc = await (0, helpers_1.readFile)(constants_1.NPMRC);
    Object.assign(npmrc, { [scopeRegistryKey]: url });
    await (0, helpers_1.writeFile)(constants_1.NPMRC, npmrc);
    (0, helpers_1.printSuccess)(`Set scope '${scopeRegistryKey}=${url}' success.`);
}
async function onDeleteScope(scopeName) {
    const scopeRegistryKey = `${scopeName}:${constants_1.REGISTRY}`;
    const npmrc = await (0, helpers_1.readFile)(constants_1.NPMRC);
    if (npmrc[scopeRegistryKey]) {
        delete npmrc[scopeRegistryKey];
        await (0, helpers_1.writeFile)(constants_1.NPMRC, npmrc);
        (0, helpers_1.printSuccess)(`Delete scope '${scopeRegistryKey}' success.`);
    }
}
async function onSetAttribute(name, { attr, value }) {
    if ((await (0, helpers_1.isRegistryNotFound)(name)) ||
        (await (0, helpers_1.isInternalRegistry)(name, 'set attribute of'))) {
        return;
    }
    if (constants_1.REPOSITORY === attr) {
        return (0, helpers_1.exit)(`Use the ${chalk_1.default.green('nrm set-hosted-repo <name> <repo>')} command to set repository.`);
    }
    const customRegistries = await (0, helpers_1.readFile)(constants_1.NRMRC);
    const registry = customRegistries[name];
    Object.assign(registry, { [attr]: value });
    await (0, helpers_1.writeFile)(constants_1.NRMRC, customRegistries);
    (0, helpers_1.printSuccess)(`Set attribute '${attr}=${value}' of the registry '${name}' successfully.`);
    const currentRegistry = await (0, helpers_1.getCurrentRegistry)();
    if (currentRegistry === registry[constants_1.REGISTRY]) {
        const npmrc = await (0, helpers_1.readFile)(constants_1.NPMRC);
        await (0, helpers_1.writeFile)(constants_1.NPMRC, Object.assign(npmrc, { [attr]: value }));
    }
}
async function onRename(name, newName) {
    if ((await (0, helpers_1.isRegistryNotFound)(name)) ||
        (await (0, helpers_1.isInternalRegistry)(name, 'rename'))) {
        return;
    }
    if (name === newName) {
        return (0, helpers_1.exit)('The names cannot be the same.');
    }
    if (!(await (0, helpers_1.isRegistryNotFound)(newName, false))) {
        return (0, helpers_1.exit)(`The new registry name '${newName}' is already exist.`);
    }
    const customRegistries = await (0, helpers_1.readFile)(constants_1.NRMRC);
    customRegistries[newName] = JSON.parse(JSON.stringify(customRegistries[name]));
    delete customRegistries[name];
    await (0, helpers_1.writeFile)(constants_1.NRMRC, customRegistries);
    (0, helpers_1.printSuccess)(`The registry '${name}' has been renamed to '${newName}'.`);
}
async function onHome(name, browser) {
    if (await (0, helpers_1.isRegistryNotFound)(name)) {
        return;
    }
    const registries = await (0, helpers_1.getRegistries)();
    if (!registries[name][constants_1.HOME]) {
        return (0, helpers_1.exit)(`The homepage of registry '${name}' is not found.`);
    }
    (0, open_1.default)(registries[name][constants_1.HOME], browser ? { app: { name: browser } } : undefined);
}
async function onTest(target) {
    const registries = await (0, helpers_1.getRegistries)();
    const timeout = 5000;
    if (target && (await (0, helpers_1.isRegistryNotFound)(target))) {
        (0, helpers_1.exit)();
    }
    const sources = target ? { [target]: registries[target] } : registries;
    const results = await Promise.all(Object.keys(sources).map(async (name) => {
        const { registry } = sources[name];
        const start = Date.now();
        let status = false;
        let isTimeout = false;
        try {
            const response = await (0, undici_1.fetch)(`${registry}nrm`, {
                signal: AbortSignal.timeout(timeout),
            });
            status = response.ok;
        }
        catch (error) {
            isTimeout = error.name === 'TimeoutError';
        }
        return {
            name,
            registry,
            success: status,
            time: Date.now() - start,
            isTimeout,
        };
    }));
    const [fastest] = results
        .filter((each) => each.success)
        .map((each) => each.time)
        .sort((a, b) => a - b);
    const messages = [];
    const currentRegistry = await (0, helpers_1.getCurrentRegistry)();
    const errorMsg = chalk_1.default.red(' (Fetch error, if this is your private registry, please ignore)');
    const timeoutMsg = chalk_1.default.yellow(` (Fetch timeout over ${timeout} ms)`);
    const length = Math.max(...Object.keys(sources).map((key) => key.length)) + 3;
    for (const { registry, success, time, name, isTimeout } of results) {
        const isFastest = time === fastest;
        const prefix = registry === currentRegistry ? chalk_1.default.green('* ') : '  ';
        let suffix = isFastest && !target
            ? chalk_1.default.bgGreenBright(`${time} ms`)
            : isTimeout
                ? 'timeout'
                : `${time} ms`;
        if (!success) {
            suffix += isTimeout ? timeoutMsg : errorMsg;
        }
        messages.push(prefix + name + (0, helpers_1.geneDashLine)(name, length) + suffix);
    }
    (0, helpers_1.printMessages)(messages);
    return messages;
}
